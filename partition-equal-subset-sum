https://leetcode.com/problems/partition-equal-subset-sum/description/

Memoization:Time-complexity:O(N*target) Space-complexity:O(N*target)+O(N)
class Solution {
    public static boolean subsetSumToK(int ind,int target,int[] arr,int dp[][]){
        if(target==0) return true;

        if(ind==0) return dp[ind][0]==target;

        boolean nontake=subsetSumToK(ind-1,target,arr,dp);
        boolean take=false;

        if(target>=arr[ind]) take=subsetSumToK(ind-1,target-arr[ind],arr,dp);
        
        dp[ind][target]=nontake|| take?1:0;
        
        
        return nontake|| take;
    }
    public boolean canPartition(int[] nums) {
        int totsum=0;

        for(int i=0;i<nums.length;i++){
            totsum+=nums[i];
        }
        if(totsum%2!=0) return false;
         int[][] dp=new int[nums.length][totsum/2+1];

         for(int row[]:dp){
            Arrays.fill(row,-1);
         }

        return subsetSumToK(nums.length-1,totsum/2,nums,dp);
    }
}

Tabulation: Time-complexity:O(N*target)  Space-complexity:O(N*target)
class Solution {
    public static boolean subsetSumToK(int ind,int target,int[] arr){
        boolean dp[][]=new boolean[ind][target+1];
        
        for(int i=0;i<ind;i++){
            dp[i][0]=true;
        }
        if(target>=arr[0])
        dp[0][arr[0]]=true;
        
        for(int i=1;i<ind;i++){
            for( int j=1;j<=target;j++){
                  boolean nontake=dp[i-1][j];
               boolean take=false;
        
           if(j>=arr[i])
              take=dp[i-1][j-arr[i]];
              
              dp[i][j]=take||nontake;
            }
        }
        
        return dp[ind-1][target];
    }
    public boolean canPartition(int[] nums) {
        int totsum=0;

        for(int i=0;i<nums.length;i++){
            totsum+=nums[i];
        }
        if(totsum%2!=0) return false;

        return subsetSumToK(nums.length,totsum/2,nums);
    }
}
