https://leetcode.com/problems/burst-balloons/

Recursion:Exponential
class Solution {
  public static int func(int i,int j,int arr[]){
    if(i>j) return 0;
   int maxi=Integer.MIN_VALUE;
    for(int ind=i;ind<=j;ind++){
      int cost=arr[i-1]*arr[ind]*arr[j+1]+func(i,ind-1,arr)+func(ind+1,j,arr);
      maxi=Math.max(maxi,cost);
    }
    return maxi;
  }
    public int maxCoins(int[] nums) {
        int n=nums.length;

        int arr[]=new int[n+2];
        arr[0]=1;
        arr[n+1]=1;
        for(int i=1;i<n+1;i++){
          arr[i]=nums[i-1];
        }

        return func(1,n,arr);
    }
}

Memoization:Time-complexity:O(N^3)  Space-complexity:O(N^2)+O(N)
class Solution {
  public static int func(int i,int j,int arr[],int dp[][]){
    if(i>j) return 0;
    if(dp[i][j]!=-1) return dp[i][j];
   int maxi=Integer.MIN_VALUE;
    for(int ind=i;ind<=j;ind++){
      int cost=arr[i-1]*arr[ind]*arr[j+1]+func(i,ind-1,arr,dp)+func(ind+1,j,arr,dp);
      maxi=Math.max(maxi,cost);
    }
    return dp[i][j]=maxi;
  }
    public int maxCoins(int[] nums) {
        int n=nums.length;

        int arr[]=new int[n+2];
        arr[0]=1;
        arr[n+1]=1;
        int dp[][]=new int[n+1][n+1];
        for(int row[]:dp) Arrays.fill(row,-1);
        for(int i=1;i<n+1;i++){
          arr[i]=nums[i-1];
        }

        return func(1,n,arr,dp);
    }
}

Tabulation:Time-complexity:O(N^3)  Space-complexity:O(N^2)
class Solution {
    public int maxCoins(int[] nums) {
        int n=nums.length;

        int arr[]=new int[n+2];
        arr[0]=1;
        arr[n+1]=1;
        int dp[][]=new int[n+2][n+2];
        for(int row[]:dp) Arrays.fill(row,0);
        for(int i=1;i<n+1;i++){
          arr[i]=nums[i-1];
        }

        for(int i=n;i>=1;i--){
          for(int j=1;j<=n;j++){
             if(i>j)  continue;
   
           int maxi=Integer.MIN_VALUE;
          for(int ind=i;ind<=j;ind++){
          int cost=arr[i-1]*arr[ind]*arr[j+1]+dp[i][ind-1]+dp[ind+1][j];
      maxi=Math.max(maxi,cost);
    }
           dp[i][j]=maxi;
          }
        }

        return dp[1][n];
    }
}
