https://leetcode.com/problems/coin-change/

Memoization:Time-complexity:O(N*T)   Space-complexity:O(N*T)+O(T)
class Solution {
    public static int func(int[] coins, int amount,int ind,int[][] dp){
        
        if(ind==0){
          if(amount%coins[0]==0) return amount/coins[0];

          else return (int)Math.pow(10,9);
        }
        if(dp[ind][amount]!=-1) return dp[ind][amount];

        int nontake=func(coins,amount,ind-1,dp);
        int take=(int)Math.pow(10,9);

        if(coins[ind]<=amount) take=1+func(coins,amount-coins[ind],ind,dp);

        return dp[ind][amount]=Math.min(nontake,take);
    }

    public int coinChange(int[] coins, int amount) {
        int n=coins.length;
        int dp[][]=new int[n][amount+1];

        for(int[] row:dp){
            Arrays.fill(row,-1);
        }
        
        int ans= func(coins, amount,n-1,dp);

        if (ans >= (int) Math.pow(10, 9))
            return -1;
        return ans;
    }
}

Tabulation:Time-complexity:O(N*T)   Space-complexity:O(N*T)

class Solution {

    public int coinChange(int[] coins, int amount) {
        int n=coins.length;
        int dp[][]=new int[n][amount+1];

        for(int tar=0;tar<=amount;tar++){
            if(tar%coins[0]==0) 
            dp[0][tar]=tar/coins[0];
            else
            dp[0][tar]=(int)Math.pow(10,9);
        }

        for(int ind=1;ind<n;ind++){
            for(int tar=0;tar<=amount;tar++){
                int nontake=dp[ind-1][tar];
                int take=(int)Math.pow(10,9);

               if(coins[ind]<=tar) 
               take=1+dp[ind][tar-coins[ind]];
               dp[ind][tar]=Math.min(take,nontake);
            }
        }

       int ans= dp[n-1][amount];

       if(ans>=(int)Math.pow(10,9)) return -1;

       return ans;
    }
}

Space-complexity: Time-complexity:O(N*T)   Space-complexity:O(T)
class Solution {

    public int coinChange(int[] coins, int amount) {
        int n=coins.length;
        int prev[]=new int[amount+1];
        int cur[]=new int[amount+1];

        for(int tar=0;tar<=amount;tar++){
            if(tar%coins[0]==0) 
            prev[tar]=tar/coins[0];
            else
            prev[tar]=(int)Math.pow(10,9);
        }

        for(int ind=1;ind<n;ind++){
            for(int tar=0;tar<=amount;tar++){
                int nontake=prev[tar];
                int take=(int)Math.pow(10,9);

               if(coins[ind]<=tar) 
               take=1+cur[tar-coins[ind]];
               cur[tar]=Math.min(take,nontake);
            }
            prev=cur;
        }

       int ans= prev[amount];

       if(ans>=(int)Math.pow(10,9)) return -1;

       return ans;
    }
}
